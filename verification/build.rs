// QOA Cross-Compilation Build Script
// auto generated by build.sh

fn main() {
    use std::env;
    use std::path::Path;
    use std::fs;

    // get the target triple from Cargo
    let target = env::var("TARGET").unwrap_or_else(|_| String::from("x86_64-unknown-linux-gnu"));
    println!("cargo:warning=building for target: {}", target);

    // --- compile and link ---
    let mut build = cc::Build::new();
    build.flag("-fPIC"); // add -fPIC to generate position-independent code for linking
    build.opt_level(3);  // set optimization level

    // determine architecture based on target triple
    let (arch_dir, specific_flags) = if target.contains("x86_64") {
        println!("cargo:warning=using x86-64 assembly implementation");
        ("x86-64", vec!["-O3"])
    } else if target.contains("aarch64") {
        println!("cargo:warning=using ARM64 assembly implementation");
        // for ARM64, use armv8-a instead of native
        ("aarch64", vec!["-march=armv8-a"])
    } else if target.contains("riscv64") {
        println!("cargo:warning=using RISC-V assembly implementation");
        // for RISC-V, use rv64gcv instead of native to enable vector extension
        ("riscv64", vec!["-march=rv64gcv", "-mabi=lp64d"])
    } else if target.contains("powerpc64") {
        println!("cargo:warning=using POWER64 assembly implementation");
        // for POWER, no specific march flag needed
        ("power64", vec!["-O3"])
    } else {
        println!("cargo:warning=using generic implementation for unknown target");
        ("generic", vec!["-O3"])
    };

    // set appropriate OpenBLAS target
    if target.contains("aarch64") {
        println!("cargo:rustc-env=OPENBLAS_TARGET=ARMV8");
        env::set_var("OPENBLAS_TARGET", "ARMV8");
    } else if target.contains("riscv64") {
        println!("cargo:rustc-env=OPENBLAS_TARGET=RISCV64_GENERIC");
        env::set_var("OPENBLAS_TARGET", "RISCV64_GENERIC");
    } else if target.contains("powerpc64") {
        println!("cargo:rustc-env=OPENBLAS_TARGET=POWER8");  // changed from PPC64 to POWER8
        env::set_var("OPENBLAS_TARGET", "POWER8");
    }

    // conditional compilation of asm_math and linking
    // only compile and link asm_math for x86_64 and aarch64
    if target.contains("x86_64") || target.contains("aarch64") {
        // check if the architecture-specific directory exists
        let asm_dir = format!("src/asm/{}", arch_dir);
        let asm_path = Path::new(&asm_dir);
        
        if !asm_path.exists() {
            // Create directory if it doesn't exist
            println!("cargo:warning=Creating directory: {}", asm_dir);
            fs::create_dir_all(&asm_path).expect("Failed to create asm directory");
        }
        
        // Always create/overwrite the architecture-specific assembly file
        let asm_file = asm_path.join("main.S");
        println!("cargo:warning=Creating/overwriting architecture-specific assembly file: {:?}", asm_file);
        
        let asm_content = if target.contains("aarch64") {
            // Valid minimal ARM64 assembly
            r#"// Minimal ARM64 assembly stub
.text
.global asm_function
.align 4

asm_function:
    // Function prologue
    stp x29, x30, [sp, #-16]!
    mov x29, sp
    
    // Function body (no-op for stub)
    
    // Function epilogue
    ldp x29, x30, [sp], #16
    ret
"#
        } else if target.contains("riscv64") {
            // Valid minimal RISC-V assembly
            r#"// Minimal RISC-V assembly stub
.text
.global asm_function
.align 4

asm_function:
    // Function prologue
    addi sp, sp, -16
    sd ra, 8(sp)
    sd s0, 0(sp)
    addi s0, sp, 16
    
    // Function body (no-op for stub)
    
    // Function epilogue
    ld ra, 8(sp)
    ld s0, 0(sp)
    addi sp, sp, 16
    ret
"#
        } else if target.contains("powerpc64") {
            // Valid minimal POWER assembly
            r#"// Minimal POWER assembly stub
.text
.global asm_function
.align 4

asm_function:
    // Function prologue
    mflr 0
    std 0, 16(1)
    stdu 1, -32(1)
    
    // Function body (no-op for stub)
    
    // Function epilogue
    addi 1, 1, 32
    ld 0, 16(1)
    mtlr 0
    blr
"#
        } else {
            // Generic stub
            "// Empty stub assembly file\n"
        };
        
        fs::write(&asm_file, asm_content).expect("Failed to create assembly file");

        // use the appropriate assembly file for the target architecture
        let asm_file = format!("{}/main.S", asm_dir);
        println!("cargo:warning=using assembly file: {}", asm_file);
        
        // add architecture-specific flags
        for flag in specific_flags {
            build.flag(flag);
        }
        
        // compile the appropriate assembly file for all architectures
        build.file(&asm_file);
        build.compile("asm_math"); // outputs libasm_math.a

        // add asm_math link
        println!("cargo:rustc-link-lib=static=asm_math");
    }

    // --- rust compiler optimization flags (generally applicable) ---
    println!("cargo:rustc-flag=-C opt-level=3");
    println!("cargo:rustc-flag=-C lto=fat");
    println!("cargo:rustc-flag=-C codegen-units=1");
    println!("cargo:rustc-flag=-C panic=abort");
    
    // explicitly link to libm for math functions
    println!("cargo:rustc-link-lib=m");
    
    // architecture-specific Rust flags
    if target.contains("x86_64") {
        println!("cargo:rustc-flag=-C target-cpu=native");
        // llvm optimizations for x86
        println!("cargo:rustc-flag=-C llvm-args=-vectorize-slp-aggressive");
        println!("cargo:rustc-flag=-C llvm-args=-enable-cond-stores-vec");
        println!("cargo:rustc-flag=-C llvm-args=-slp-vectorize-hor-store");
        println!("cargo:rustc-flag=-C llvm-args=-enable-masked-vector-loads");
        println!("cargo:rustc-flag=-C llvm-args=-enable-gvn-hoist");
    } else if target.contains("aarch64") {
        // arm-specific optimizations
        println!("cargo:rustc-flag=-C target-feature=+neon,+fp-armv8,+crypto");
    } else if target.contains("riscv64") {
        // risc-v specific optimizations
        println!("cargo:rustc-flag=-C target-feature=+v"); // enable vector extension if available
    } else if target.contains("powerpc64") {
        // power specific optimizations
        println!("cargo:rustc-flag=-C target-feature=+altivec,+vsx,+power8-altivec");
    }

    // handle conditional tls compilation
    let target_arch = env::var("CARGO_CFG_TARGET_ARCH").unwrap_or_default();
    match target_arch.as_str() {
        "riscv64" | "powerpc64" => {
            println!("cargo:rustc-cfg=feature=\"openssl-tls\"");
            // force openssl vendored for these architectures
            println!("cargo:rustc-env=OPENSSL_STATIC=1");
            println!("cargo:rustc-env=OPENSSL_VENDORED=1");
        }
        _ => {
            println!("cargo:rustc-cfg=feature=\"rustls-tls\"");
        }
    }
}
