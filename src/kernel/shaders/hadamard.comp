#version 450

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// Quantum state storage
layout(set = 0, binding = 0) buffer QuantumState {
    vec4 amplitudes[];  // Each vec4 contains two complex numbers (re1, im1, re2, im2)
};

// Push constants for gate parameters
layout(push_constant) uniform PushConstants {
    uint targetQubit;
    uint stateSize;
    uint reserved1;
    uint reserved2;
} params;

// Complex number multiplication
vec2 cmul(vec2 a, vec2 b) {
    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}

void main() {
    uint idx = gl_GlobalInvocationID.x;
    if (idx >= params.stateSize) return;
    
    // Calculate the two indices that will be mixed by the Hadamard gate
    uint mask = 1u << params.targetQubit;
    uint idx0 = idx & ~mask;  // Index with target qubit = 0
    uint idx1 = idx | mask;   // Index with target qubit = 1
    
    // Only process each pair once (when idx has target bit = 0)
    if ((idx & mask) != 0) return;
    
    // Fetch the two amplitudes to be modified
    uint vec_idx0 = idx0 / 2;
    uint vec_idx1 = idx1 / 2;
    bool odd0 = (idx0 & 1) != 0;
    bool odd1 = (idx1 & 1) != 0;
    
    vec2 psi0, psi1;
    
    // Extract complex amplitudes from packed storage
    if (odd0) {
        psi0 = vec2(amplitudes[vec_idx0].z, amplitudes[vec_idx0].w);
    } else {
        psi0 = vec2(amplitudes[vec_idx0].x, amplitudes[vec_idx0].y);
    }
    
    if (odd1) {
        psi1 = vec2(amplitudes[vec_idx1].z, amplitudes[vec_idx1].w);
    } else {
        psi1 = vec2(amplitudes[vec_idx1].x, amplitudes[vec_idx1].y);
    }
    
    // Hadamard transform: 1/sqrt(2) * [1 1; 1 -1]
    float inv_sqrt2 = 0.7071067811865475; // 1/sqrt(2)
    vec2 new_psi0 = inv_sqrt2 * (psi0 + psi1);
    vec2 new_psi1 = inv_sqrt2 * (psi0 - psi1);
    
    // Memory barrier to ensure all threads finish reading before writing
    memoryBarrier();
    
    // Store results back to global memory
    if (odd0) {
        amplitudes[vec_idx0].z = new_psi0.x;
        amplitudes[vec_idx0].w = new_psi0.y;
    } else {
        amplitudes[vec_idx0].x = new_psi0.x;
        amplitudes[vec_idx0].y = new_psi0.y;
    }
    
    if (odd1) {
        amplitudes[vec_idx1].z = new_psi1.x;
        amplitudes[vec_idx1].w = new_psi1.y;
    } else {
        amplitudes[vec_idx1].x = new_psi1.x;
        amplitudes[vec_idx1].y = new_psi1.y;
    }
}